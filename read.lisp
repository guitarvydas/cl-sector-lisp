(defun @read(str)
  (let ((lstr (@listify-string str)))
    (@lread lstr)))

(defun @listify-string(s)
  (concatenate 'list s))

(defun @lread(raw-lstr)
  (let ((lstr (@trim-leading-spaces raw-lstr)))
    (if (char= #\( (car lstr))
	(multiple-value-bind (result leftover)
	    (@lread-list lstr)
	  (if (char= #\) (car leftover))
	      (values result (cdr leftover))
	      (@read-error (format nil "while reading list ~a, expected ')' but got ~a" raw-lstr leftover))))
	(@lread-atom lstr))))

(defun @lread-list (raw-lstr)
  (let ((lstr (@trim-leading-spaces raw-lstr)))
    (if (@empty lstr)
	(%NIL)
	(let ((front (@upto-separator lstr)))
	  (let ((tail (@after-separator-inclusive lstr)))
	    (%cons (@lread front) (@lread-list tail)))))))

(defun @lread-atom (raw-lstr)
  (let ((lstr (@trim-leading-spaces raw-lstr)))
    (let ((front (@upto-separator lstr)))
      (let ((tail (@after-separator-inclusive lstr)))
	(let ((atom-index (@lread front)))
	  (values atom-index tail))))))

(defun %cons (a b) (cons a b))
(defun %NIL () nil)
(defun @trim-leading-spaces (lstr)
  (if lstr
      (if (char= #\Space (car lstr))
	  (@trim-leading-spaces (cdr lstr))
	  lstr)
      nil))
(defun @upto-separator (lstr)
  (reverse (@upto-separator-helper lstr)))
(defun @upto-separator-helper (lstr)
  (if (null lstr)
      nil
      (if (@is-separator (car lstr))
          nil
        (cons (car lstr) (@upto-separator-helper (cdr lstr))))))
(defun @after-separator-inclusive (lstr)
  (@after-separator-inclusive-helper lstr))
(defun @after-separator-inclusive-helper (lstr)
  (if (null lstr)
      nil
      (if (@is-separator (car lstr))
          (cdr lstr)
        (@after-separator-inclusive-helper (cdr lstr)))))
(defun @is-separator (c)
  (or (char= c #\Space)
      (char= c #\()
      (char= c #\))))
(defun @empty(s) (= 0 (length s)))
(defun @read-error (s)
  (format *error-output* "~a~%" s)
  (assert nil))

(defun rtest ()
  (@read "x"))